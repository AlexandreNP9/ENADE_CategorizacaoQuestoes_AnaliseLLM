```json
{
  "numero": "20",
  "conteudo_principal": "Análise de Algoritmos de Busca (Linear e Binária), Complexidade de Algoritmos e Paradigmas de Programação (Recursão vs. Iteração).",
  "justificativa_correta": "A alternativa correta é a 'A', pois apenas a afirmação I está correta.\n\n**Análise da Afirmação I:**\nPara a `funcao1(vetor, 15)` (busca linear):\nO vetor é `{1, 3, 5, 7, 9, 11, 13, 15, 17, 19}`.\nA função percorre o vetor sequencialmente. O valor `15` está na posição de índice `7` (contando de `0`). Portanto, `funcao1` retorna `7`.\n\nPara a `funcao2(vetor, 15, 0, TAM-1)` (busca binária):\nÉ uma busca binária no vetor `vetor` pelo valor `15`, com `i=0` e `f=9`.\n1.  Primeira chamada: `funcao2(vetor, 15, 0, 9)`\n    *   `m = (0 + 9) / 2 = 4`\n    *   `vetor[4]` é `9`. `15 > 9`, então a busca continua na metade direita.\n    *   Chama: `funcao2(vetor, 15, 4+1, 9)` ou seja `funcao2(vetor, 15, 5, 9)`\n2.  Segunda chamada: `funcao2(vetor, 15, 5, 9)`\n    *   `m = (5 + 9) / 2 = 7`\n    *   `vetor[7]` é `15`. `15 == 15`, o valor é encontrado.\n    *   Retorna `7`.\n\nAmbas as funções retornam `7`. Assim, a impressão na linha 24 será `7 - 7`. A afirmação I está **CORRETA**.",
  "justificativas_erradas": {
    "II": "A afirmação II está **INCORRETA**.\n*   A `funcao1` implementa uma busca linear. No pior caso (elemento não encontrado ou encontrado na última posição), ela precisa percorrer todos os `N` elementos do vetor, resultando em uma complexidade de tempo O(N).\n*   A `funcao2` implementa uma busca binária. No pior caso, ela divide o problema pela metade a cada etapa, resultando em uma complexidade de tempo O(log N).\nPara um `N` suficientemente grande, O(log N) é significativamente mais rápido que O(N). Mesmo para `N=10`, a busca binária é mais eficiente (aproximadamente 3-4 comparações vs. até 10 para a linear). Portanto, `funcao1` não é mais rápida que `funcao2` no pior caso; na verdade, é o contrário.",
    "III": "A afirmação III está **INCORRETA**.\nA `funcao2` é um exemplo clássico de algoritmo **recursivo**. Ela resolve um problema chamando a si mesma (funcao2) com subproblemas menores, até atingir uma condição de parada (casos base: `v == vetor[m]` ou `i >= f`). Uma estratégia iterativa, por outro lado, usa estruturas de repetição (loops como `for` ou `while`) para realizar as etapas, sem que a função chame a si mesma. A `funcao1` é um exemplo de algoritmo iterativo."
  },
  "dcn_relacionadas": [
    "3.1. Conteúdos Curriculares da Formação Tecnológica e Básica para todos os Cursos de Bacharelado e de Licenciatura: algoritmos e complexidade; abstração e estruturas de dados; programação.",
    "5. Competências e Habilidades Gerais dos Egressos dos Cursos de Bacharelado e de Licenciatura: I - identificar problemas que tenham solução algorítmica; III - resolver problemas usando ambientes de programação; V - compreender e explicar as dimensões quantitativas de um problema."
  ],
  "nivel_cognitivo": "Médio",
  "tags": [
    "Algoritmos de Busca",
    "Busca Linear",
    "Busca Binária",
    "Análise de Complexidade",
    "Recursão",
    "Iteração",
    "Linguagem C",
    "Estruturas de Dados (Array)"
  ]
}
```